# Задание 5
## Расчёт статистических характеристик последовательности
&emsp;&emsp;Познакомимся (или вспомним) с довольно важными понятиями при обработке данных, и попутно
() закрепим навыки использования полиморфизма в коде.

&emsp;&emsp;За все время своего существования Человечество изобрело огромное количество способов анализа
последовательности данных. Все мы, конечно, рассматривать не будем – эту деятельность мы
оставим науке Статистика. Но часть из этих достижений представляют собой практическую
ценность.

&emsp;&emsp;Представим себе, что нам нужно замерить время выполнения некоторого кода. Например, с целью
сравнения двух разных алгоритмов вычисления и выбора оптимального. Казалось бы – сделать это
легко. Мы просто засекаем время до начала выполнения алгоритма, потом запускаем код, который
нужно оценить по скорости, и по окончанию его выполнения останавливаем замер времени.

***Пример кода:***
```c++
#include <chrono> // библиотека для работы с метками времени
auto startTime = std::chrono::system_clock::now(); // текущее время
runAlgorithm(); // запуск алгоритма
auto endTime = std::chrono::system_clock::now(); // текущее время
auto milliseconds = std::chrono::duration_cast<
std::chrono::milliseconds>(
endTime – startTime
); // получаем значение разницы в миллисекундах
```
&emsp;&emsp;Библиотеку <chrono> мы ещё не изучали, и код может выглядеть немного страшно. Но суть простая
– мы получаем две метки времени, а потом вычисляем разницу в миллисекундах.

&emsp;&emsp;Пример, с которым можно поэкспериментировать приложен в материалах – см.
`chrono_example.cpp`. В нем замеряются два разных алгоритма сортировки массива значений
(std::vector). При этом перед запуском сортировки массив каждый раз случайно перемешивается с
использованием генератора случайных чисел. Отдельно с функциональностью случайного
перемешивания можно ознакомиться в примере `random_shuffle.cpp` из материалов.

&emsp;&emsp;Проблема такого рода замеров заключается в том, что наша операционная система (ОС) вовсе не
планирует нам помогать в достижении поставленной задачи. Ей неведомо, что мы тут замерами с
высокой точностью занимаемся – она может запустить обновление системы, спланировать поиск
вирусов или любую другую ресурсоёмкую активность. Плюс распределение памяти для нашего
приложения может работать от запуска к запуску более или менее удачно. В общем, есть
множество причин, по которым наш код может работать не совсем стабильно.

&emsp;&emsp;Поэтому обычно практикуется подход, когда замеряется не единичный прогон той или иной
функции, а выполняется несколько (несколько сотен или даже тысяч) прогонов и оценка статистики
поведения. При этом рассматриваются сразу несколько статистических характеристик.

&emsp;&emsp;Например, мало информативно узнать, что среднее арифметическое всех замеров представляет
собой значение (например) == 10.124 ms. Желательно посмотреть ещё минимальное и
максимальное значения, а также получить оценку отклонений.

Вот статистикой мы и займёмся.
## Формулировка задания
На вход (стандартный ввод) приложению подаётся последовательность (заранее неизвестного
размера) числовых значений. Приложение должно в ходе своей работы считать всю
последовательность из стандартного ввода и вывести на экран набор следующих статистических
характеристик:
- [min](https://ru.wikipedia.org/wiki/%D0%9C%D0%B0%D0%BA%D1%81%D0%B8%D0%BC%D0%B0%D0%BB%D1%8C%D0%BD%D1%8B%D0%B5_%D0%B8_%D0%BC%D0%B8%D0%BD%D0%B8%D0%BC%D0%B0%D0%BB%D1%8C%D0%BD%D1%8B%D0%B5_%D1%8D%D0%BB%D0%B5%D0%BC%D0%B5%D0%BD%D1%82%D1%8B) – минимальное значение из последовательности
- [max](https://ru.wikipedia.org/wiki/%D0%9C%D0%B0%D0%BA%D1%81%D0%B8%D0%BC%D0%B0%D0%BB%D1%8C%D0%BD%D1%8B%D0%B5_%D0%B8_%D0%BC%D0%B8%D0%BD%D0%B8%D0%BC%D0%B0%D0%BB%D1%8C%D0%BD%D1%8B%D0%B5_%D1%8D%D0%BB%D0%B5%D0%BC%D0%B5%D0%BD%D1%82%D1%8B) – максимальное значение из последовательности
- [mean](https://ru.wikipedia.org/wiki/%D0%A1%D1%80%D0%B5%D0%B4%D0%BD%D0%B5%D0%B5_%D0%B0%D1%80%D0%B8%D1%84%D0%BC%D0%B5%D1%82%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%BE%D0%B5) – арифметическое среднее, посчитанное на основе всех элементов последовательности
- [std](https://ru.wikipedia.org/wiki/%D0%A1%D1%80%D0%B5%D0%B4%D0%BD%D0%B5%D0%BA%D0%B2%D0%B0%D0%B4%D1%80%D0%B0%D1%82%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%BE%D0%B5_%D0%BE%D1%82%D0%BA%D0%BB%D0%BE%D0%BD%D0%B5%D0%BD%D0%B8%D0%B5) - среднеквадратическое отклонение
- [опционально] [pct90](https://ru.wikipedia.org/wiki/%D0%9A%D0%B2%D0%B0%D0%BD%D1%82%D0%B8%D0%BB%D1%8C) - 90-й процентиль
- [опционально] [pct95](https://ru.wikipedia.org/wiki/%D0%9A%D0%B2%D0%B0%D0%BD%D1%82%D0%B8%D0%BB%D1%8C) - 95-й процентиль
- 
Пункты, помеченные как [опционально] представляю собой «задачу со звёздочкой» и могут не
выполняться.

&emsp;&emsp;Остановка ввода последовательности предполагается путём передачи признака `EOF` (End Of File). В
Windows это делается путём следующего набора команд: Ctrl+Z, Enter. В Linux это делается путём
нажатия `Ctrl+D`.

***Пример работы приложения:***
```bash
> statistics
0 1 2 3 4 5 6 7 8 9 10
min = 0
max = 10
mean = 5
std = 3.162277
pct90 = 9
pct95 = 10
```
&emsp;&emsp;Стоит заметить, что результаты могут отличаться в зависимости от реализации. Так, например,
некоторые реализации могут выдать значение pct95 = 9.5. Или значения std, отличные от того, что
указано выше, за счёт иного округления результата.
## Уточнения по реализации
- расчёт каждого вида статистики должен представлять собой отдельный класс
- , представляющий собой наследника класса `IStatistics`
- и реализующий чисто виртуальную функции последнего\
Макет приложения можно посмотреть в файле `statistics.cpp` из материалов.
## Итоговые требования
1. создать приложение расчёта статистики
2. для сборки использовать `CMake`
3. выгрузить результат на github.com в свой аккаунт
В Чат с преподавателем в Личном кабинете отправить:
1. ссылку на репозиторий с исходниками приложения

